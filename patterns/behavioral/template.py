"""
Что такое паттерн шаблонный метод?

Шаблонный метод - это паттерн, который определяет "скелет" алгоритма в базовом классе,
но позволяет подклассам переопределить некоторые шаги этого алгоритма
без изменения его общей структуры. Простыми словами, шаблонный метод представляет
собой шаблон для решения определенной задачи, где некоторые шаги могут быть
изменены или дополнены в подклассах.

Как это работает?

Представьте, что у вас есть задача разработать приложение для создания различных
типов документов: текстовых, электронных таблиц, презентаций и т. д. Вместо того,
чтобы реализовывать каждый тип документа отдельно, мы можем использовать паттерн "Шаблонный метод".

Мы создаем базовый класс "Документ", который определяет общую структуру и
основные шаги создания любого документа. Затем мы создаем подклассы для каждого
типа документа, которые переопределяют только необходимые шаги, специфичные для каждого типа.

Преимущества использования паттерна "Шаблонный метод":

✅ Упрощение разработки: шаблонный метод помогает разделить сложный алгоритм
на более мелкие шаги, что упрощает разработку и делает код более понятным.

✅ Повторное использование кода: общая структура алгоритма находится
в базовом классе, поэтому мы можем повторно использовать ее для разных подклассов.

✅ Гибкость: подклассы могут изменять или дополнять только нужные шаги алгоритма,
оставляя остальную структуру без изменений.

✅ Удобство тестирования: тестирование отдельных шагов алгоритма проще,
чем тестирование всего алгоритма целиком.

Участники
✅ AbstractClass: определяет шаблонный метод TemplateMethod(),
который реализует алгоритм. Алгоритм может состоять из последовательности
вызовов других методов, часть из которых может быть абстрактными и должны быть
переопределены в классах-наследниках. При этом сам метод TemplateMethod(),
представляющий структуру алгоритма, переопределяться не должен.

✅ConcreteClass: подкласс, который может переопределять различные методы родительского класса.

Резюме
Паттерн "Шаблонный метод" помогает нам создавать гибкие и
повторно используемые алгоритмы, а также упрощает разработку и
позволяет легко изменять определенные шаги в подклассах.

*Examples in Python ecosystem:
Django class based views: https://docs.djangoproject.com/en/2.1/topics/class-based-views/
"""


def get_text() -> str:
    return "plain-text"


def get_pdf() -> str:
    return "pdf"


def get_csv() -> str:
    return "csv"


def convert_to_text(data: str) -> str:
    print("[CONVERT]")
    return f"{data} as text"


def saver() -> None:
    print("[SAVE]")


def template_function(getter, converter=False, to_save=False) -> None:
    data = getter()
    print(f"Got `{data}`")

    if len(data) <= 3 and converter:
        data = converter(data)
    else:
        print("Skip conversion")

    if to_save:
        saver()

    print(f"`{data}` was processed")


def main():
    """
    >>> template_function(get_text, to_save=True)
    Got `plain-text`
    Skip conversion
    [SAVE]
    `plain-text` was processed

    >>> template_function(get_pdf, converter=convert_to_text)
    Got `pdf`
    [CONVERT]
    `pdf as text` was processed

    >>> template_function(get_csv, to_save=True)
    Got `csv`
    Skip conversion
    [SAVE]
    `csv` was processed
    """


if __name__ == "__main__":
    import doctest

    doctest.testmod()
