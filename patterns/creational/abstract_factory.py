"""
Этот шаблон называется Шаблоном Абстрактной Фабрики.

Что представляет собой этот шаблон?
Шаблон Абстрактной Фабрики является шаблоном проектирования, относящимся к категории создания объектов.
Он предоставляет интерфейс для создания семейств связанных или зависимых объектов, не указывая их конкретных классов.
Это позволяет создавать объекты на основе определенных условий, таких как бизнес-логика,
выбор платформы или другие критерии, не раскрывая конкретных деталей реализации.

Что делает этот пример?
Представленный вами пример абстрагирует создание домашних животных (конкретно, собак и кошек) с использованием
абстрактной фабрики. В зависимости от выбранной фабрики (DogFactory, CatFactory или random_animal),
он создает экземпляры домашних животных, которые следуют общему интерфейсу. Эти домашние животные могут
быть использованы в приложении, не зная их конкретных типов. Это позволяет приложению создавать домашних
 животных в абстрактной форме и принимать решения на основе определенных критериев о том,
  какой тип домашнего животного создать (например, собаки вместо кошек).

Где практически используется этот шаблон?
Шаблон Абстрактной Фабрики используется в программной разработке для достижения гибкости
и поддерживаемости. Его часто применяют в ситуациях, где требуется создание семейств связанных объектов,
таких как компоненты пользовательского интерфейса в кросс-платформенном приложении, адаптеры баз данных
для разных систем управления базами данных или в любом сценарии, где необходимо разрывать связь между
кодом клиента и конкретными реализациями объектов.

Ссылки:

    SourceMaking - Шаблон Абстрактной Фабрики
    Шаблоны проектирования в стиле Python

Кратко:
Шаблон Абстрактной Фабрики предоставляет способ инкапсулировать группу отдельных фабрик,
 позволяя создавать семейства связанных объектов, не указывая их конкретные классы,
  и способствуя гибкости и поддерживаемости в вашем коде.
"""

import random
from typing import Type


class Pet:
    def __init__(self, name: str) -> None:
        self.name = name

    def speak(self) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class Dog(Pet):
    def speak(self) -> None:
        print("woof")

    def __str__(self) -> str:
        return f"Dog<{self.name}>"


class Cat(Pet):
    def speak(self) -> None:
        print("meow")

    def __str__(self) -> str:
        return f"Cat<{self.name}>"


class PetShop:

    """Зоомагазин"""

    def __init__(self, animal_factory: Type[Pet]) -> None:
        """pet_factory - это наш абстрактный завод. Мы можем устанавливать его по своему усмотрению."""

        self.pet_factory = animal_factory

    def buy_pet(self, name: str) -> Pet:
        """Создает и предоставляет питомца с использованием абстрактной фабрики"""

        pet = self.pet_factory(name)
        print(f"Вот ваш милый {pet}")
        return pet


# Дополнительные фабрики:


# Создание случайного животного
def random_animal(name: str) -> Pet:
    """Давайте будем динамичными!"""
    return random.choice([Dog, Cat])(name)


# Показать питомцев с разными фабриками
def main() -> None:
    """
    # Магазин, который продает только кошек
    >>> cat_shop = PetShop(Cat)
    >>> pet = cat_shop.buy_pet("Lucy")
    Вот ваш милый Cat<Люси>
    >> pet.speak()
    мяу

    # Магазин, который продает случайных животных
    >>> shop = PetShop(random_animal)
    >>> for name in ["Max", "Jack", "Buddy"]:
    ...    pet = shop.buy_pet(name)
    ...    pet.speak()
    ...    print("=" * 20)
    Вот ваш милый Cat<Макс>
    мяу
    ====================
    Вот ваш милый Dog<Джек>
    гав
    ====================
    Вот ваш милый Dog<Бадди>
    гав
    ====================
    """


if __name__ == "__main__":
    random.seed(1234)  # for deterministic doctest outputs
    shop = PetShop(random_animal)
    import doctest

    doctest.testmod()
